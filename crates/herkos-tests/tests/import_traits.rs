//! End-to-end tests for import handling and trait generation (Phase 3, Milestone 3).
//!
//! These tests verify that:
//! 1. The transpiler generates trait definitions from imports
//! 2. Functions with imports have correct trait bounds
//! 3. Export methods forward the host parameter correctly
//! 4. Host implementations can call exported functions

use herkos_runtime::WasmResult;
use herkos_tests::import_basic;

// Mock host implementation for testing
struct MockHost {
    last_printed: Option<i32>,
    read_value: i32,
    fd_write_result: i32,
}

impl MockHost {
    fn new() -> Self {
        MockHost {
            last_printed: None,
            read_value: 42,
            fd_write_result: 0,
        }
    }
}

// Implement the EnvImports trait that was generated
impl import_basic::EnvImports for MockHost {
    fn print_i32(&mut self, arg0: i32) -> WasmResult<()> {
        self.last_printed = Some(arg0);
        Ok(())
    }

    fn read_i32(&mut self) -> WasmResult<i32> {
        Ok(self.read_value)
    }
}

// Implement the WasiSnapshotPreview1Imports trait that was generated
impl import_basic::WasiSnapshotPreview1Imports for MockHost {
    fn fd_write(&mut self, _arg0: i32, _arg1: i32, _arg2: i32, _arg3: i32) -> WasmResult<i32> {
        Ok(self.fd_write_result)
    }
}

#[test]
fn test_trait_generation() {
    // Verify that the traits were generated by attempting to use them
    let mut host = MockHost::new();
    let mut module = import_basic::new().unwrap();

    // Counter should start at 0
    assert_eq!(module.get_counter().unwrap(), 0);

    // Call exported function that uses imports
    let result = module.test_imports(100, &mut host).unwrap();

    // Verify the import was called
    assert_eq!(
        host.last_printed,
        Some(100),
        "print_i32 should have been called with 100"
    );

    // Verify the return value (read_i32 returns 42, +10 = 52)
    assert_eq!(result, 52, "Should return read_i32() + 10");

    // Counter should have been incremented
    assert_eq!(module.get_counter().unwrap(), 1);
}

#[test]
fn test_wasi_import() {
    let mut host = MockHost::new();
    host.fd_write_result = 123;
    let mut module = import_basic::new().unwrap();

    // Call exported function that uses WASI import
    let result = module.test_wasi(&mut host).unwrap();

    assert_eq!(result, 123, "Should return fd_write result");
}

#[test]
fn test_multiple_trait_bounds() {
    // This test verifies that a host implementing multiple traits can be used
    struct MultiHost;

    impl import_basic::EnvImports for MultiHost {
        fn print_i32(&mut self, _arg0: i32) -> WasmResult<()> {
            Ok(())
        }

        fn read_i32(&mut self) -> WasmResult<i32> {
            Ok(99)
        }
    }

    impl import_basic::WasiSnapshotPreview1Imports for MultiHost {
        fn fd_write(&mut self, _arg0: i32, _arg1: i32, _arg2: i32, _arg3: i32) -> WasmResult<i32> {
            Ok(77)
        }
    }

    let mut host = MultiHost;
    let mut module = import_basic::new().unwrap();

    // Both functions should work with the same host
    let result1 = module.test_imports(5, &mut host).unwrap();
    assert_eq!(result1, 109); // 99 + 10

    let result2 = module.test_wasi(&mut host).unwrap();
    assert_eq!(result2, 77);
}
