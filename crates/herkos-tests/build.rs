use anyhow::{Context, Result};
use herkos::{transpile, TranspileOptions};
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn main() -> Result<()> {
    // Rerun build script if this file or any data files change
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=data");

    // Use cargo's OUT_DIR for generated files (parallel-build safe)
    let out_dir = PathBuf::from(env::var("OUT_DIR").context("OUT_DIR not set")?);
    eprintln!(
        "Generating WASM and transpiled modules to: {}",
        out_dir.display()
    );

    let options = TranspileOptions::default();
    let mut module_names = Vec::new();

    // 1. WAT test cases from data/wat/*.wat
    let wat_names = process_wat_files(Path::new("data/wat"), &out_dir, &options)?;
    module_names.extend(wat_names);

    // 2. Rust → Wasm → Rust end-to-end test cases from data/rust/*.rs
    let rust_e2e_names = process_rust_e2e_files(Path::new("data/rust"), &out_dir, &options)?;
    module_names.extend(rust_e2e_names);

    // 3. C → Wasm → Rust end-to-end test cases from data/c/*.c
    let c_e2e_names = process_c_e2e_files(Path::new("data/c"), &out_dir, &options)?;
    module_names.extend(c_e2e_names);

    // Generate module manifest
    let mut manifest = String::from("// Auto-generated module manifest\n");
    manifest.push_str("// DO NOT EDIT - generated by build.rs\n\n");

    for name in &module_names {
        manifest.push_str(&format!("pub mod {};\n", name));
    }

    fs::write(out_dir.join("mod.rs"), manifest).context("failed to write mod.rs")?;

    eprintln!("Transpilation complete! ({} modules)", module_names.len());
    Ok(())
}

// ─── WAT processing ─────────────────────────────────────────────────────────

/// Scan `data/wat/*.wat`, parse each to Wasm, transpile to Rust.
fn process_wat_files(
    wat_dir: &Path,
    out_dir: &Path,
    options: &TranspileOptions,
) -> Result<Vec<String>> {
    let mut entries = collect_files_with_ext(wat_dir, "wat")?;
    entries.sort(); // deterministic build order
    eprintln!(
        "Processing {} WAT test cases from {}...",
        entries.len(),
        wat_dir.display()
    );

    let mut names = Vec::new();

    for path in &entries {
        let name = file_stem(path)?;
        eprintln!("  WAT: {} ...", name);

        let wat_source = fs::read_to_string(path)
            .with_context(|| format!("failed to read {}", path.display()))?;

        let wasm_bytes = wat::parse_str(&wat_source)
            .with_context(|| format!("failed to parse WAT for {}", name))?;

        let wasm_path = out_dir.join(format!("{}.wasm", name));
        fs::write(&wasm_path, &wasm_bytes)
            .with_context(|| format!("failed to write {}.wasm", name))?;

        let rust_code = transpile(&wasm_bytes, options)
            .with_context(|| format!("failed to transpile {}", name))?;

        let module_path = out_dir.join(format!("{}.rs", name));
        fs::write(&module_path, &rust_code)
            .with_context(|| format!("failed to write {}.rs", name))?;

        names.push(name);
    }

    Ok(names)
}

// ─── Rust E2E processing ────────────────────────────────────────────────────

/// Scan `data/rust/*.rs`, compile each to Wasm via rustc, then transpile.
///
/// Gracefully skips if the wasm32-unknown-unknown target is not installed.
fn process_rust_e2e_files(
    rust_dir: &Path,
    out_dir: &Path,
    options: &TranspileOptions,
) -> Result<Vec<String>> {
    // Check if wasm32-unknown-unknown sysroot exists
    let sysroot_output = std::process::Command::new("rustc")
        .args(["--print", "sysroot"])
        .output()
        .context("failed to run rustc --print sysroot")?;

    let sysroot = String::from_utf8_lossy(&sysroot_output.stdout);
    let sysroot = sysroot.trim();
    let target_dir = PathBuf::from(sysroot).join("lib/rustlib/wasm32-unknown-unknown");

    if !target_dir.exists() {
        eprintln!(
            "cargo:warning=wasm32-unknown-unknown target not installed; \
             skipping Rust E2E tests. Run: rustup target add wasm32-unknown-unknown"
        );
        return Ok(Vec::new());
    }

    let mut entries = collect_files_with_ext(rust_dir, "rs")?;
    entries.sort();
    eprintln!(
        "Processing {} Rust E2E test cases (Rust → Wasm → Rust)...",
        entries.len()
    );

    // Transpile options: max_pages=2 to keep IsolatedMemory small enough
    // for test thread stacks (8 MiB in debug mode).
    let e2e_options = TranspileOptions {
        max_pages: 2,
        ..options.clone()
    };

    let mut names = Vec::new();

    for path in &entries {
        let name = file_stem(path)?;
        eprintln!("  Rust E2E: {} ...", name);

        // Copy source to OUT_DIR for rustc
        let rs_src_path = out_dir.join(format!("{}_src.rs", name));
        fs::copy(path, &rs_src_path)
            .with_context(|| format!("failed to copy {} to OUT_DIR", path.display()))?;

        // Compile to Wasm
        let wasm_path = out_dir.join(format!("{}.wasm", name));
        let compile_output = std::process::Command::new("rustc")
            .args([
                "--target",
                "wasm32-unknown-unknown",
                "--crate-type",
                "cdylib",
                "--edition",
                "2021",
                "-C",
                "opt-level=z",
                "-C",
                "lto=yes",
                // Reduce the Wasm stack size from the default 1 MiB to 64 KiB,
                // then set initial/max memory to 2 pages (128 KiB).
                // This keeps the transpiled IsolatedMemory small enough for
                // test thread stacks (8 MiB in debug mode).
                "-C",
                "link-arg=-zstack-size=65536",
                "-C",
                "link-arg=--initial-memory=131072",
                "-C",
                "link-arg=--max-memory=131072",
            ])
            .arg(&rs_src_path)
            .arg("-o")
            .arg(&wasm_path)
            .output()
            .with_context(|| format!("failed to invoke rustc for {}", name))?;

        if !compile_output.status.success() {
            let stderr = String::from_utf8_lossy(&compile_output.stderr);
            eprintln!(
                "cargo:warning=Failed to compile {} to Wasm: {}",
                name, stderr
            );
            continue;
        }

        // Read, transpile, write
        let wasm_bytes =
            fs::read(&wasm_path).with_context(|| format!("failed to read {}.wasm", name))?;

        let rust_code = transpile(&wasm_bytes, &e2e_options)
            .with_context(|| format!("failed to transpile {} from Rust-compiled Wasm", name))?;

        let module_path = out_dir.join(format!("{}.rs", name));
        fs::write(&module_path, &rust_code)
            .with_context(|| format!("failed to write {}.rs", name))?;

        names.push(name);
    }

    Ok(names)
}

// ─── C E2E processing ───────────────────────────────────────────────────────

/// Scan `data/c/*.c`, compile each to Wasm via clang, then transpile.
///
/// Gracefully skips if `clang` (with wasm32 target support) is not available.
fn process_c_e2e_files(
    c_dir: &Path,
    out_dir: &Path,
    options: &TranspileOptions,
) -> Result<Vec<String>> {
    // Try clang-19 first, then fall back to clang
    let clang = if command_succeeds("clang-19", &["--version"]) {
        "clang-19"
    } else if command_succeeds("clang", &["--version"]) {
        "clang"
    } else {
        eprintln!(
            "cargo:warning=clang not found; skipping C E2E tests. \
             Install with: apt-get install clang lld"
        );
        return Ok(Vec::new());
    };

    let mut entries = collect_files_with_ext(c_dir, "c")?;
    entries.sort();
    eprintln!(
        "Processing {} C E2E test cases (C → Wasm → Rust) using {}...",
        entries.len(),
        clang
    );

    // Transpile options: max_pages=2 to match --max-memory=131072
    let e2e_options = TranspileOptions {
        max_pages: 2,
        ..options.clone()
    };

    let mut names = Vec::new();

    for path in &entries {
        let name = file_stem(path)?;
        eprintln!("  C E2E: {} ...", name);

        // Copy source to OUT_DIR for clang
        let c_src_path = out_dir.join(format!("{}_src.c", name));
        fs::copy(path, &c_src_path)
            .with_context(|| format!("failed to copy {} to OUT_DIR", path.display()))?;

        // Compile C → Wasm using clang with freestanding settings
        let wasm_path = out_dir.join(format!("{}.wasm", name));
        let compile_output = std::process::Command::new(clang)
            .args([
                "--target=wasm32-unknown-unknown",
                "-nostdlib",
                "-Oz",
                // Linker flags: no entry point, export all symbols
                "-Wl,--no-entry",
                "-Wl,--export-all",
                // Reduce the Wasm stack from the default 1 MiB to 64 KiB,
                // then set initial/max memory to 2 pages (128 KiB).
                // This keeps the transpiled IsolatedMemory small enough
                // for test thread stacks (8 MiB in debug mode).
                "-Wl,-zstack-size=65536",
                "-Wl,--initial-memory=131072",
                "-Wl,--max-memory=131072",
            ])
            .arg(&c_src_path)
            .arg("-o")
            .arg(&wasm_path)
            .output()
            .with_context(|| format!("failed to invoke {} for {}", clang, name))?;

        if !compile_output.status.success() {
            let stderr = String::from_utf8_lossy(&compile_output.stderr);
            eprintln!(
                "cargo:warning=Failed to compile {} to Wasm: {}",
                name, stderr
            );
            continue;
        }

        // Read, transpile, write
        let wasm_bytes =
            fs::read(&wasm_path).with_context(|| format!("failed to read {}.wasm", name))?;

        let rust_code = transpile(&wasm_bytes, &e2e_options)
            .with_context(|| format!("failed to transpile {} from C-compiled Wasm", name))?;

        let module_path = out_dir.join(format!("{}.rs", name));
        fs::write(&module_path, &rust_code)
            .with_context(|| format!("failed to write {}.rs", name))?;

        names.push(name);
    }

    Ok(names)
}

// ─── Helpers ────────────────────────────────────────────────────────────────

/// Collect all files with the given extension from a directory.
fn collect_files_with_ext(dir: &Path, ext: &str) -> Result<Vec<PathBuf>> {
    if !dir.exists() {
        return Ok(Vec::new());
    }
    let mut files = Vec::new();
    for entry in fs::read_dir(dir).with_context(|| format!("failed to read {}", dir.display()))? {
        let entry = entry?;
        let path = entry.path();
        if path.extension().and_then(|e| e.to_str()) == Some(ext) {
            files.push(path);
        }
    }
    Ok(files)
}

/// Extract the file stem as a String (used as module name).
fn file_stem(path: &Path) -> Result<String> {
    path.file_stem()
        .and_then(|s| s.to_str())
        .map(|s| s.to_string())
        .with_context(|| format!("invalid file name: {}", path.display()))
}

/// Check if a command runs successfully.
fn command_succeeds(cmd: &str, args: &[&str]) -> bool {
    std::process::Command::new(cmd)
        .args(args)
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false)
}
