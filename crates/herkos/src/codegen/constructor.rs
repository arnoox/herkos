//! Constructor and initialization code generation.
//!
//! Handles generation of:
//! - Module/LibraryModule constructors
//! - Const items for immutable globals
//! - Element segment initialization
//! - Data segment initialization

use crate::backend::Backend;
use crate::ir::*;
use anyhow::Result;

/// Emit preamble for generated Rust files.
pub fn rust_code_preamble() -> String {
    let mut code = String::new();
    code.push_str("// Generated by herkos\n");
    code.push_str("// DO NOT EDIT\n\n");
    code.push_str("use herkos_runtime::*;\n\n");
    code
}

/// Generate const items for immutable globals.
pub fn emit_const_globals<B: Backend>(_backend: &B, info: &ModuleInfo) -> String {
    let mut code = String::new();
    for (idx, g) in info.globals.iter().enumerate() {
        if !g.mutable {
            let (rust_ty, value_str) = crate::codegen::types::global_init_to_rust(&g.init_value);
            code.push_str(&format!("pub const G{idx}: {rust_ty} = {value_str};\n"));
        }
    }
    if info.globals.iter().any(|g| !g.mutable) {
        code.push('\n');
    }
    code
}

/// Generate element segment initialization code for a table.
///
/// Element segments are declared in the Wasm binary's `element` section. Each
/// segment specifies a base offset into the table and a list of function
/// references to write into consecutive slots starting at that offset. This
/// function emits the Rust `table.set(...)` calls that perform those writes
/// inside the generated module's `new()` constructor.
pub fn emit_element_segments(info: &ModuleInfo, table_receiver: &str) -> Result<String> {
    let mut code = String::new();

    // A Wasm module may declare multiple element segments, each covering a
    // contiguous slice of table slots at a different base offset.
    for seg in &info.element_segments {
        // `seg.offset` is the base table index for this segment.
        // `seg.func_indices` lists the local function indices to place into
        // consecutive slots: slot (offset+0), (offset+1), ...
        // All indices are already in the local index space (imports subtracted).
        for (i, local_func_idx) in seg.func_indices.iter().enumerate() {
            // Absolute table slot = segment base + position within segment.
            let table_idx = seg.offset + i;

            // Each table entry records the function's canonical type index so
            // that `call_indirect` can validate the expected signature at the
            // call site before dispatching. We fetch it from the IR function.
            let type_idx = info
                .ir_function(*local_func_idx)
                .map(|f| f.type_idx.as_usize())
                .ok_or(anyhow::anyhow!("Invalid function index"))?;

            // Emit one table initialisation statement per slot.
            //
            // TODO: `.unwrap()` panics if `table_idx` exceeds the table's
            //       allocated size. The table is sized from the same Wasm module
            //       so this should be unreachable, but it is not formally proven.
            //       Generated code should use `?` and propagate a
            //       `ConstructionError` to stay panic-free (required by no_std).
            code.push_str(&format!(
                "    {}.set({}, Some(FuncRef {{ type_index: {}, func_index: {} }})).unwrap();\n",
                table_receiver,            // "module.table" or "table"
                table_idx,                 // absolute slot in the table
                type_idx,                  // for type-checking on call_indirect
                local_func_idx.as_usize()  // which function to dispatch to
            ));
        }
    }
    Ok(code)
}

/// Generate the `pub fn new() -> WasmModule` or `pub fn new() -> WasmResult<WasmModule>` constructor.
pub fn generate_constructor<B: Backend>(
    _backend: &B,
    info: &ModuleInfo,
    has_mut_globals: bool,
) -> Result<String> {
    let mut code = String::new();

    // Simple constructor for modules with no initialization
    if !info.has_memory
        && !has_mut_globals
        && info.data_segments.is_empty()
        && info.element_segments.is_empty()
    {
        code.push_str("pub fn new() -> Result<WasmModule, ConstructionError> {\n");
        code.push_str("    Ok(WasmModule(LibraryModule::new((), Table::try_new(0)?)))\n");
        code.push_str("}\n");
        return Ok(code);
    }

    code.push_str("pub fn new() -> WasmResult<WasmModule> {\n");

    // Build globals initializer
    let globals_init = if has_mut_globals {
        let mut fields = String::from("Globals { ");
        let mut first = true;
        for (idx, g) in info.globals.iter().enumerate() {
            if g.mutable {
                if !first {
                    fields.push_str(", ");
                }
                let (_, value_str) = crate::codegen::types::global_init_to_rust(&g.init_value);
                fields.push_str(&format!("g{idx}: {value_str}"));
                first = false;
            }
        }
        fields.push_str(" }");
        fields
    } else {
        "()".to_string()
    };

    // Table initialization
    let table_init = if info.has_table() {
        format!("Table::try_new({})?", info.table_initial)
    } else {
        "Table::try_new(0)?".to_string()
    };

    if info.has_memory {
        let needs_mut = !info.data_segments.is_empty() || !info.element_segments.is_empty();
        let binding = if needs_mut {
            "let mut module"
        } else {
            "let module"
        };
        code.push_str(&format!(
            "    {} = Module::try_new({}, {}, {}).map_err(|_| WasmTrap::OutOfBounds)?;\n",
            binding, info.initial_pages, globals_init, table_init
        ));

        // Data segment initialization (byte-by-byte)
        for seg in &info.data_segments {
            for (i, byte) in seg.data.iter().enumerate() {
                let addr = seg.offset as usize + i;
                code.push_str(&format!(
                    "    module.memory.store_u8({}, {})?;\n",
                    addr, byte
                ));
            }
        }

        // Element segment initialization
        code.push_str(&emit_element_segments(info, "module.table")?);

        code.push_str("    Ok(WasmModule(module))\n");
    } else if !info.element_segments.is_empty() {
        // Need mutable table for element initialization
        code.push_str(&format!("    let mut table = {};\n", table_init));
        code.push_str(&emit_element_segments(info, "table")?);
        code.push_str(&format!(
            "    Ok(WasmModule(LibraryModule::new({}, table)))\n",
            globals_init
        ));
    } else {
        code.push_str(&format!(
            "    Ok(WasmModule(LibraryModule::new({}, {})))\n",
            globals_init, table_init
        ));
    }

    code.push_str("}\n");
    Ok(code)
}
