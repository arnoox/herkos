//! Constructor and initialization code generation.
//!
//! Handles generation of:
//! - Module/LibraryModule constructors
//! - Const items for immutable globals
//! - Element segment initialization
//! - Data segment initialization

use crate::backend::Backend;
use crate::ir::*;
use anyhow::Result;

/// Emit preamble for generated Rust files.
pub fn rust_code_preamble() -> String {
    let mut code = String::new();
    code.push_str("// Generated by herkos\n");
    code.push_str("// DO NOT EDIT\n\n");
    code.push_str("use herkos_runtime::*;\n\n");
    code
}

/// Generate const items for immutable globals.
pub fn emit_const_globals<B: Backend>(_backend: &B, info: &ModuleInfo) -> String {
    let mut code = String::new();
    for (idx, g) in info.globals.iter().enumerate() {
        if !g.mutable {
            let (rust_ty, value_str) = crate::codegen::types::global_init_to_rust(&g.init_value);
            code.push_str(&format!("pub const G{idx}: {rust_ty} = {value_str};\n"));
        }
    }
    if info.globals.iter().any(|g| !g.mutable) {
        code.push('\n');
    }
    code
}

/// Generate element segment initialization code for a table.
///
/// Element segments are declared in the Wasm binary's `element` section. Each
/// segment specifies a base offset into the table and a list of function
/// references to write into consecutive slots starting at that offset. This
/// function emits one `table.init_elements(...)` call per segment, which is
/// bounds-checked inside the runtime and propagates errors via `?`.
pub fn emit_element_segments(info: &ModuleInfo, table_receiver: &str) -> Result<String> {
    let mut code = String::new();

    for seg in &info.element_segments {
        if seg.func_indices.is_empty() {
            continue;
        }

        // Build &[(type_index, func_index), ...] literal for init_elements.
        // All indices are already in the local index space (imports subtracted).
        let mut pairs: Vec<String> = Vec::new();
        for local_func_idx in &seg.func_indices {
            let type_idx = info
                .ir_function(*local_func_idx)
                .map(|f| f.type_idx.as_usize())
                .ok_or(anyhow::anyhow!("Invalid function index"))?;
            pairs.push(format!("({}, {})", type_idx, local_func_idx.as_usize()));
        }

        code.push_str(&format!(
            "    {}.init_elements({}, &[{}])?;\n",
            table_receiver,
            seg.offset,
            pairs.join(", ")
        ));
    }
    Ok(code)
}

/// Generate the `pub fn new() -> WasmModule` or `pub fn new() -> WasmResult<WasmModule>` constructor.
pub fn generate_constructor<B: Backend>(
    _backend: &B,
    info: &ModuleInfo,
    has_mut_globals: bool,
) -> Result<String> {
    let mut code = String::new();

    // Simple constructor for modules with no initialization
    if !info.has_memory
        && !has_mut_globals
        && info.data_segments.is_empty()
        && info.element_segments.is_empty()
    {
        code.push_str("pub fn new() -> Result<WasmModule, ConstructionError> {\n");
        code.push_str("    Ok(WasmModule(LibraryModule::new((), Table::try_new(0)?)))\n");
        code.push_str("}\n");
        return Ok(code);
    }

    code.push_str("pub fn new() -> WasmResult<WasmModule> {\n");

    // Build globals initializer
    let globals_init = if has_mut_globals {
        let mut fields = String::from("Globals { ");
        let mut first = true;
        for (idx, g) in info.globals.iter().enumerate() {
            if g.mutable {
                if !first {
                    fields.push_str(", ");
                }
                let (_, value_str) = crate::codegen::types::global_init_to_rust(&g.init_value);
                fields.push_str(&format!("g{idx}: {value_str}"));
                first = false;
            }
        }
        fields.push_str(" }");
        fields
    } else {
        "()".to_string()
    };

    // Table initialization
    let table_init = if info.has_table() {
        format!("Table::try_new({})?", info.table_initial)
    } else {
        "Table::try_new(0)?".to_string()
    };

    if info.has_memory {
        let needs_mut = !info.data_segments.is_empty() || !info.element_segments.is_empty();
        let binding = if needs_mut {
            "let mut module"
        } else {
            "let module"
        };
        code.push_str(&format!(
            "    {} = Module::try_new({}, {}, {}).map_err(|_| WasmTrap::OutOfBounds)?;\n",
            binding, info.initial_pages, globals_init, table_init
        ));

        // Data segment initialization â€” one bulk call per segment
        for seg in &info.data_segments {
            let bytes: Vec<String> = seg.data.iter().map(|b| format!("{}u8", b)).collect();
            code.push_str(&format!(
                "    module.memory.init_data({}, &[{}])?;\n",
                seg.offset,
                bytes.join(", ")
            ));
        }

        // Element segment initialization
        code.push_str(&emit_element_segments(info, "module.table")?);

        code.push_str("    Ok(WasmModule(module))\n");
    } else if !info.element_segments.is_empty() {
        // Need mutable table for element initialization
        code.push_str(&format!("    let mut table = {};\n", table_init));
        code.push_str(&emit_element_segments(info, "table")?);
        code.push_str(&format!(
            "    Ok(WasmModule(LibraryModule::new({}, table)))\n",
            globals_init
        ));
    } else {
        code.push_str(&format!(
            "    Ok(WasmModule(LibraryModule::new({}, {})))\n",
            globals_init, table_init
        ));
    }

    code.push_str("}\n");
    Ok(code)
}
