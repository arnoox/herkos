//! Constructor and initialization code generation.
//!
//! Handles generation of:
//! - Module/LibraryModule constructors
//! - Const items for immutable globals
//! - Element segment initialization
//! - Data segment initialization

use crate::backend::Backend;
use crate::ir::*;

/// Emit preamble for generated Rust files.
pub fn rust_code_preamble() -> String {
    let mut code = String::new();
    code.push_str("// Generated by herkos\n");
    code.push_str("// DO NOT EDIT\n\n");
    code.push_str("use herkos_runtime::*;\n\n");
    code
}

/// Generate const items for immutable globals.
pub fn emit_const_globals<B: Backend>(_backend: &B, info: &ModuleInfo) -> String {
    let mut code = String::new();
    for (idx, g) in info.globals.iter().enumerate() {
        if !g.mutable {
            let (rust_ty, value_str) =
                crate::codegen::types::global_init_to_rust(&g.init_value, &g.wasm_type);
            code.push_str(&format!("pub const G{idx}: {rust_ty} = {value_str};\n"));
        }
    }
    if info.globals.iter().any(|g| !g.mutable) {
        code.push('\n');
    }
    code
}

/// Generate element segment initialization code for a table.
///
/// `table_receiver` is the expression to access the table (e.g., "module.table" or "table").
pub fn emit_element_segments(info: &ModuleInfo, table_receiver: &str) -> String {
    let mut code = String::new();
    for seg in &info.element_segments {
        for (i, func_idx) in seg.func_indices.iter().enumerate() {
            let table_idx = seg.offset + i;
            let local_func_idx = *func_idx - info.num_imported_functions();
            let type_idx = info
                .func_signatures
                .get(local_func_idx)
                .map(|s| s.type_idx)
                .unwrap_or(0);
            code.push_str(&format!(
                "    {}.set({}, Some(FuncRef {{ type_index: {}, func_index: {} }})).unwrap();\n",
                table_receiver, table_idx, type_idx, local_func_idx
            ));
        }
    }
    code
}

/// Generate the `pub fn new() -> WasmModule` or `pub fn new() -> WasmResult<WasmModule>` constructor.
pub fn generate_constructor<B: Backend>(
    _backend: &B,
    info: &ModuleInfo,
    has_mut_globals: bool,
) -> String {
    let mut code = String::new();

    // Simple constructor for modules with no initialization
    if !info.has_memory
        && !has_mut_globals
        && info.data_segments.is_empty()
        && info.element_segments.is_empty()
    {
        code.push_str("pub fn new() -> Result<WasmModule, herkos_runtime::ConstructionError> {\n");
        code.push_str("    Ok(WasmModule(LibraryModule::new((), Table::try_new(0)?)))\n");
        code.push_str("}\n");
        return code;
    }

    code.push_str("pub fn new() -> WasmResult<WasmModule> {\n");

    // Build globals initializer
    let globals_init = if has_mut_globals {
        let mut fields = String::from("Globals { ");
        let mut first = true;
        for (idx, g) in info.globals.iter().enumerate() {
            if g.mutable {
                if !first {
                    fields.push_str(", ");
                }
                let (_, value_str) =
                    crate::codegen::types::global_init_to_rust(&g.init_value, &g.wasm_type);
                fields.push_str(&format!("g{idx}: {value_str}"));
                first = false;
            }
        }
        fields.push_str(" }");
        fields
    } else {
        "()".to_string()
    };

    // Table initialization
    let table_init = if info.has_table() {
        format!("Table::try_new({})?", info.table_initial)
    } else {
        "Table::try_new(0)?".to_string()
    };

    if info.has_memory {
        let needs_mut = !info.data_segments.is_empty() || !info.element_segments.is_empty();
        let binding = if needs_mut {
            "let mut module"
        } else {
            "let module"
        };
        code.push_str(&format!(
            "    {} = Module::try_new({}, {}, {}).map_err(|_| WasmTrap::OutOfBounds)?;\n",
            binding, info.initial_pages, globals_init, table_init
        ));

        // Data segment initialization (byte-by-byte)
        for seg in &info.data_segments {
            for (i, byte) in seg.data.iter().enumerate() {
                let addr = seg.offset as usize + i;
                code.push_str(&format!(
                    "    module.memory.store_u8({}, {})?;\n",
                    addr, byte
                ));
            }
        }

        // Element segment initialization
        code.push_str(&emit_element_segments(info, "module.table"));

        code.push_str("    Ok(WasmModule(module))\n");
    } else if !info.element_segments.is_empty() {
        // Need mutable table for element initialization
        code.push_str(&format!("    let mut table = {};\n", table_init));
        code.push_str(&emit_element_segments(info, "table"));
        code.push_str(&format!(
            "    Ok(WasmModule(LibraryModule::new({}, table)))\n",
            globals_init
        ));
    } else {
        code.push_str(&format!(
            "    Ok(WasmModule(LibraryModule::new({}, {})))\n",
            globals_init, table_init
        ));
    }

    code.push_str("}\n");
    code
}
